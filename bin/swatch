#!/usr/bin/env python3

import os
import argparse
import subprocess
import time
from typing import List, NoReturn
from datetime import datetime


FILETYPE_COMMANDS = {
    ".py": "python3",
    ".go": "go run",
}
FS_SCAN_DELAY = 0.1
RECURSIVE_MAX_FILE = 1000


def run_command(command: str) -> None:
    print(f"\n[{datetime.now().strftime('%H:%M:%S')}] $ {command}")
    start_time = time.monotonic()
    # TODO: can we run this in the same shell? (with the same env vars, etc)
    subprocess.run(command, shell=True, text=True)
    print(f"\ncommand finished in {time.monotonic() - start_time:.1f} seconds")


class SingleFileWatcher:
    def __init__(self, path: str, command: str):
        self.path = path
        self.update_time = 0
        self.command = command
        self.check_file()

    def check_file(self) -> bool:
        """Update the file time, returning true if there was an update."""
        update_time_old = self.update_time

        try:
            self.update_time = os.stat(self.path).st_mtime
        except Exception as e:
            raise Exception(f"Update file time failed with exception {e}")

        return self.update_time > update_time_old

    def start(self) -> NoReturn:
        while True:
            if self.check_file():
                run_command(self.command)
            time.sleep(FS_SCAN_DELAY)


def create_command(file: str, args: List[str]) -> str:
    _, filetype = os.path.splitext(file)
    if filetype not in FILETYPE_COMMANDS:
        raise argparse.ArgumentTypeError(
            f"Filetype {filetype} not supported. Please provide and explicit command with --command or use a file with filetype {list(FILETYPE_COMMANDS.keys())}"
        )
    return " ".join([FILETYPE_COMMANDS[filetype], file] + args)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Watch a file and run a command when it changes",
    )
    parser.add_argument(
        "path",
        help="The file/directory to watch for changes",
    )
    parser.add_argument(
        "-c",
        "--command",
        required=False,
        help="Command to run when file changes, if not provided will infer from file extension",
    )
    parser.add_argument(
        "args",
        nargs="*",
        help="Additional arguments to pass to the command",
    )
    args = parser.parse_args()

    if not os.path.isfile(args.path) and not os.path.isdir(args.path):
        raise argparse.ArgumentTypeError(
            f"Path {args.path} is neither a file or a directory"
        )

    if args.command:
        command = args.command
    elif os.path.isfile(args.path):
        command = create_command(args.path, args.args)
    else:
        raise argparse.ArgumentTypeError(
            f"When providing a directory the command must be specified explicitly with --command"
        )

    path = os.path.abspath(os.path.expanduser(args.path))
    print(f'Watching path "{path}" and running command "{command}" on changes')

    if os.path.isfile(path):
        watcher = SingleFileWatcher(path, command)
    else:
        pass

    try:
        watcher.start()
    except KeyboardInterrupt:
        pass
